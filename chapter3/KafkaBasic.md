# 3.1 카프카 기초

카프카를 구성하는 주요 요소  

`주키퍼(ZooKeeper)`: 아파치 프로젝트 애플리케이션의 이름입니다. 카프카의 메타데이터 관리 및 브로커의 정상상태 점검을 담당합니다.  
`카프카(Kafka), 카프카 클러스터(Kafka cluster)`: 아파치 프로젝트 애플리케이션의 이름입니다. 여러 대의 브로커를 구성한 클러스터를 의미합니다.  
`브로커(broker)`: 카프카 애플리케이션이 설치된 서버 또는 노드를 의미합니다.  
`프로듀서(producer)`: 카프카로 메시지를 보내는 역할을 하는 클라이언트를 총칭합니다.  
`컨슈머(consumer)`: 카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트를 총칭합니다.  
`토픽(topic)`: 카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유합니다.  
`파티션(partition)`: 병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말합니다.  
`세그먼트(segment)`: 프로듀서가 전송한 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일을 말합니다.  
`메시지 또는 레코드`: 프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각을 말합니다.  


## 3.1.1 리플리케이션

카프카에서 리플리케이션(replication)이란 각 메시지들을 여러 개로 복제해서 카프카 클러스터내 브로커들에 분산시키는 동작을 의미합니다.  
이러한 리플리케이션 동작 덕분에 하나의 브로커가 종료되더라도 카프카는 안정성을 유지할 수 있습니다.  

exam토픽을 리플리케이션 팩터 수 3으로 설정한다면 3개의 브로커들에게 각각 exam토픽이 존재하고 따라서 원본을 포함하여 3개의 exam토픽이 존재하게 됩니다.  
(정확하게 말하면, 토픽이 리플리케이션되는 것이 아니라 토픽의 파티션이 리플리케이션 되는 것입니다.)  

리플리케이션 팩터 수가 커지면 안정성은 높아지지만 그만큼 브로커 리소스를 많이 사용하게 됩니다.  
따라서 복제에 대한 오버헤드를 줄여서 최대한 브로커를 효율적으로 사용하는 것을 권장합니다.  

보통 팩터 수가 3일 경우에 충분히 메시지 안정성도 보장하고 적절한 디스크 공간을 사용할 수 있습니다.  

## 3.1.2 파티션

하나의 토픽이 한 번에 처리할 수 잇는 한계를 높이기 위해 토픽 하나를 여러개로 나눠 병렬 처리가 가능하게 만든 것을 파티션이라고 합니다.  
이렇게 하나를 여러개로 나누면 분산처리도 가능하며 나뉜 파티션의 수만큼 컨슈머를 연결할 수 있습니다.  
(파티션 번호는 0번부터 시작)  

파티션 수도 토픽을 생성할 때 옵션으로 설정하게 되는데, 파티션 수를 정하는 기준은 다소 모호한 경우가 많이 있습니다.  
특히 파티션 수는 초기 생성 후 언제든지 늘릴 수 있지만, 반대로 한 번 늘린 파티션 수는 절대로 줄일 수 없다는 점을 명심해야 합니다.  

따라서 초기에 토픽을 생성할 때 파티션 수를 작게 생성한 후, 메시지 처리량이나 컨슈머의 LAG 등을 모니터링 하면서 조금씩 늘려가는 방법이 가장 좋습니다.  
(LAG란, 프로듀서가 보낸 메시지 수 - 컨슈머가 가져간 메시지 수)


## 3.1.3 세그먼트  

프로듀서에 의해 브로커로 전송된 메시지는 토픽의 파티션에 저장되며, 각 메시지들은 세그먼트라는 로그 파일의 형태로 브로커의 로컬 디스크에 저장됩니다.  
각 파티션마다 N개의 세그먼트 로그 파일이 존재합니다.  

`디렉토리`: {topic}-{partition number}/00000000000000.log

## 정리

1. 프로듀서는 카프카의 exam 토픽으로 메시지를 전송합니다.  
2. exam 토픽은 파티션이 하나뿐이므로, 프로듀서로부터 받은 메시지를 파티션0의 세그먼트 로그 파일에 저장합니다.  
3. 브로커의 세그먼트 로그 파일에 저장된 메시지는 컨슈머가 읽어갈 수 있습니다.  


