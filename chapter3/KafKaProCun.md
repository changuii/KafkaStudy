# 3.3 프로듀서와 컨슈머의 기본 동작


## 3.3.1 프로듀서 기본 동작 및 디자인

카프카 프로듀서는 토픽, 파티션, 키, 밸류로 구성되는 파티션이라는 형태로 전송합니다.  
프로듀서가 카프카로 레코드를 전송할 때, 카프카의 특정 토픽으로 메시지를 전송합니다. 따라서 레코드에서 토픽과 밸류(메시지)는 필숫값이며, 특정 파티션을 지정하기 위한 레코드의 파티션과 특정 파티션에 레코드들을 정렬하기 위한 레코드의 키는 필숫값이 아닌 선택사항, 옵션입니다.  

각 레코드들은 프로듀서의 send() 메소드를 통해 시리얼라이저, 파티셔너를 거치게 됩니다.  
만약 프로듀서가 레코드의 선택사항인 파티션을 지정했다면, 파티셔너는 아무 동작도 하지 않고 지정된 파티션으로 레코드를 전달합니다.  

파티션을 지정하지 않은 경우에는 키를 가지고 파티션을 선택해 레코드를 전달하는데, 기본적으로는 라운드로빈 방식으로 동작합니다.  
이렇게 프로듀서 내부에서는 send() 메소드 동작 이후 레코드들을 파티션별로 잠시 모아두게 됩니다.  

레코드들을 모아두는 이유는 프로듀서가 카프카로 전송하기 전, 배치 전송을 하기 위함입니다.  
전송이 실패하면 재시도 동작이 이뤄지고, 지정된 횟수만큼의 재시도가 실패하면 최종 실패를 전달하며, 전송이 성공하면 메타데이터를 리턴하게 됩니다.  

## 3.3.2 컨슈머의 기본 동작  

프로듀서가 카프카의 토픽으로 메시지를 전송하면 해당 메시지들은 브로커들의 로컬 디스크에 저장됩니다.  
그리고 우리는 컨슈머를 이용해 토픽에 저장된 메시지를 가져올 수 있습니다.  

컨슈머 그룹은 하나 이상의 컨슈머들이 모여있는 그룹을 의미하고, 컨슈머는 반드시 컨슈머 그룹에 속하게 됩니다.  
그리고 이 컨슈머 그룹은 각 파티션의 리더에게 카프카 토픽에 저장된 메시지를 가져오기 위한 요청을 보냅니다.  

이때 파티션 수와 컨슈머의 수(하나의 컨슈머 그룹 안에 있는 컨슈머의 수)는 일대일로 매핑되는 것이 이상적입니다.  
물론 파티션 수와 컨슈머 수의 비율을 반드시 일대일로 매핑해야하는 것은 아니지만, 파티션 수보다 컨슈머 수가 많게 구현하는 것은 바람직한 구성은 아닙니다.  
왜냐하면 컨슈머 수가 파티션 수보다 더 많다고 해서 더 빠르게 토픽의 메시지를 가져오거나 처리량이 높아지는 것이 아니라 더 많은 수의 컨슈머들이 그냥 대기 상태로 존재하기 때문입니다.  

간혹 액티브/스탠바이 개념으로 추가 컨슈머가 더 있으면 좋을 것이라고 생각할 수도 있지만, 컨슈머 그룹내에서 리밸런싱 동작을 통해 장애가 발생한 컨슈머의 역할을 동일한 그룹에 있는 다른 컨슈머가 그 역할을 대신 수행하므로 굳이 장애 대비를 위한 추가 컨슈머 리소스를 할당하지 않아도 됩니다.  


## 3.3.3 컨슈머 그룹의 이해

컨슈머는 컨슈머 그룹 안에 속한것이 일반적인 구조로, 하나의 컨슈머 그룹 안에 여러 개의 컨슈머가 구성될 수 있습니다.  
그리고 컨슈머들은 토픽의 파티션과 일대일로 매핑되어 메시지를 가져오게 됩니다.  

| 토픽    | 컨슈머그룹 |
| ------- | ---------- |
| 파티션0 | 컨슈머1    |
| 파티션1 | 컨슈머2    |
| 파티션2 | 컨슈머3    |  

이렇게 컨슈머들은 하나의 컨슈머 그룹 안에 속해 있으며, 그룹 내의 컨슈머들은 서로의 정보를 공유합니다.  
예를 들어 컨슈머1이 문제가 생겨 종료됬다면, 컨슈머2 또는 컨슈머3은 컨슈머1이 하던 일을 대신해 토픽의 파티션0을 컨슙하기 시작합니다.  







