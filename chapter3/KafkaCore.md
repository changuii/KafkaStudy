# 3.2 카프카 핵심 개념


왜 카프카가 안정적이고, 어떻게 높은 처리량을 갖게 되었는지에 대한 구체적인 내용을 서술  


## 3.2.1 분산 시스템

분산 시스템은 네트워크상에서 연결된 컴퓨터들의 그룹을 말하며, 단일 시스템이 갖지 못한 높은 성능을 목표로 합니다.  
분산시스템의 장점  
- `성능이 높다.`
- 하나의 서버 또는 노드 등에 장애가 발생할 때 다른 서버 또는 노드가 대신 처리하므로 `장애 대응이 탁월`하다.
- 부하가 높은 경우에는 `시스템 확장이 용이`하다.

카프카도 분산 시스템이므로 최초 구성한 클러스터의 리소스가 한계치에 도달해 더욱 높은 메시지 처리량이 필요한 경우, 브로커를 추가하는 방식으로 확장이 가능하다.  
최초에는 하나의 카프카 클러스터가 총 3대의 브로커로 운영 중이어도, 서비스가 폭발적으로 증가할 경우 나중엔 총 30대 또는 50대 또는 그 이상의 브로커 수로 확장할 수 있습니다.  

이렇게 `확장이 용이하다`는 점은 카프카의 매우 큰 장점입니다.  

## 3.2.2 페이지 캐시

카프카는 높은 처리량을 얻기 위해 몇 가지 기능을 추가했는데, 그 중 대표적인 것이 바로 `페이지 캐시`의 이용입니다.  

페이지 캐시는 직접 디스크에 읽고 쓰는 대신 물리 메모리 중 애플리케이션이 사용하지 않는 일부 잔여 메모리를 활용합니다.  
이렇게 페이지 캐시를 이용하면 디스크I/O에 대한 접근이 줄어듬으로써 `성능을 높일 수` 있습니다.  

카프카가 OS의 페이지 캐시를 이용한다는 것은 카프카가 직접 디스크에서 읽고 쓰기를 하지 않고 페이지 캐시를 통해 읽고 쓰기를 한다고 이해하면 됩니다.  

## 3.2.3 배치 전송 처리 

카프카는 프로듀서, 컨슈머 클라이언트들과 서로 통신하며, 이들 사이에서 수 많은 메시지를 주고받습니다.  
이때 발생하는 수많은 통신을 묶어서 처리할 수 있다면, 단건으로 통신할 때에 비해 네트워크 오버헤드를 줄일 수 있을 뿐만 아니라 장기적으로는 `더욱 빠르고 효율적으로 처리`할 수 있습니다.  

예시  
| 그룹        | 방식                       | 기차에 탑승하는 승객 수 | 필요한 기차 수 |
| ----------- | -------------------------- | ----------------------- | -------------- |
| 실시간 그룹 | 개개인이 도착하면 출발     | 1명                     | 10대           |
| 배치 그룹   | 모든 승객을 기다린 후 출발 | 10명                    | 1대 |  


## 3.2.4 압축 전송 

카프카는 메시지 전송 시 좀 더 성능이 높은 압축 전송을 사용하는 것을 권장합니다.  
카프카에서 지원하는 압축 타입은 gzip, snappy, lz4, zstd 등 입니다.  

압축만으로도 네트워크 `대역폭이나 회선 비용 등을 줄일` 수 있는데, 앞서 설명한 배치 전송과 결합해 사용한다면 더욱 높은 효과를 얻게 됩니다.  
파일 하나를 압축하는 것보다 비슷한 파일 10개, 혹은 20개를 압축하는 쪽의 압축 효율이 더욱 좋기 때문입니다.  


## 3.2.5 토픽, 파티션, 오프셋

카프카에서는 토픽이라는 곳에 데이터를 저장하는데, 이는 우리가 흔히 사용하는 메일 전송 시스템에서 이메일 주소 정도의 개념으로 이해하면 쉽습니다.  
토픽은 `병렬 처리`를 위해 여러개의 파티션이라는 단위로 다시 나뉩니다.  

카프카에서는 이와 같은 파티셔닝을 통해 단 하나의 토픽이라도 `높은 처리량`을 수행할 수 있습니다.  
이 파티션의 메시지가 저장되는 위치를 오프셋이라고 부르며, 오프셋은 순차적으로 증가하는 숫자 형태로 되어 있습니다.  

각 파티션에서의 오프셋은 고유한 숫자로, 카프카에서는 오프셋을 통해 메시지의 순서를 보장하고 컨슈머는 마지막까지 읽은 위치를 알 수도 있습니다.  


## 3.2.6 고가용성 보장

카프카는 앞서 설명한 것처럼 분산 시스템이기 때문에 하나의 서버나 노드가 다운되어도 다른 서버 또는 노드가 장애가 발생한 서버의 역할을 대신해 안정적인 서비스가 가능합니다.  

이러한 `고가용성을 보장`하기 위해 카프카에서는 `리플리케이션 기능`을 제공합니다.  
카프카에서 제공하는 리플리케이션 기능은 토픽 자체를 복제하는 것이 아니라 토픽의 파티션을 복제하는 것입니다.  

토픽을 생성할 때 옵션으로 리플리케이션 팩터 수를 지정할 수 있으며, 이 숫자에 따라 리플리케이션들이 존재하게 됩니다.  
원본과 리플리케이션을 구분하기 위해 흔히 마스터, 미러 같은 용어를 사용하는데 카프카에서는 `리더`와 `팔로워`라고 부릅니다.  

리플리케이션 팩터 수에 따른 리더와 팔로워 수  
| 리플리케이션 팩터 수 | 리더 수 | 팔로워 수 |
| :------------------: | :-----: | :-------: |
|          2           |    1    |     1     |
|          3           |    1    |     2     |
|          4           |    1    |     3     |   

일반적으로 팔로워의 수가 많을수록 안정적이고 좋을 거라 생각할 수 있겠지만 팔로워의 수가 많다고 딱히 좋은 것은 아닙니다.  
팔로워의 수만큼 결국 브로커의 디스크공간도 소비되므로 이상적인 리플리케이션 팩터 수를 유지해야 하며, 일반적으로 카프카에서는 리플리케이션 팩터 수를 3으로 구성하도록 권장합니다.  

리더는 프로듀서, 컨슈머로부터 오는 모든 읽기와 쓰기 요청을 처리하며, 팔로워는 오직 리더로부터 리플리케이션 하게 됩니다.  

## 3.2.7 주키퍼의 의존성

카프카를 언급하면서 빼놓을 수 없는 부분이 바로 주키퍼입니다.  
코디네이터 역할을 하는 애플리케이션입니다.  

주키퍼는 여러 대의 서버를 앙상블(클러스터)로 구성하고, 살아 있는 노드 수가 과반수 이상 유지된다면 지속적인 서비스가 가능한 구조입니다.  
따라서 주키퍼는 반드시 홀수로 구성해야 합니다.  

지노드를 이용하여 카프카의 메타 정보가 주키퍼에 기록되며, 주키퍼는 이러한 지노드를 이용해 브로커의 노드관리, 토픽관리, 컨트롤러관리 등 매우 중요한 역할을 하고 있습니다.  
하지만 최근 들어 카프카가 점점 성장하면서 주키퍼의 성능의 한계가 들어나기 시작했고 주키퍼의 한계에서 벗어나고자 카프카에서 주키퍼에 대한 의존성을 제거하려는 움직임이 한참 진행중입니다.  







