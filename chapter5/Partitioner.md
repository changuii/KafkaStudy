# 5.1 파티셔너  

카프카의 토픽은 성능 향상을 위한 병렬 처리가 가능하도록 하기 위해 파티션으로 나뉘고 최소 하나 또는 둘 이상의 파티션으로 구성됩니다.  
그리고 프로듀서가 카프카로 전송한 메시지는 해당 토픽 내 각 파티션의 로그 세그먼트에 저장됩니다.  

따라서 프로듀서는 토픽으로 메시지를 보낼 때 해당 토픽의 어느 파티션으로 메시지를 보내야 할지를 결정해야 하는데, 이때 사용하는 것이 바로 파티셔너(partitioner)입니다.  
프로듀서가 파티션을 결정하는 알고리즘은 기본적으로 메시지(레코드)의 키를 해시처리해 파티션을 구하는 방식을 사용합니다.  

따라서 메시지의 키값이 동일하면 해당 메시지들은 모두 같은 파티션으로 전송됩니다.  

예상치 못한 많은 양의 메시지가 카프카로 인입되는 경우, 카프카는 클라이언트의 처리량을 높이기 위해 토픽의 파티션을 늘릴 수 있는 기능을 제공합니다.  
이때 파티션 수가 변경됨과 동시에, 메시지의 키와 매핑된 해시 테이블도 변경됩니다.  

따라서 프로듀서가 동일한 메시지의 키를 이용해 메시지를 전송하더라도 파티션의 수를 늘린 후에는 다른 파티션으로 전송될 수 있습니다.  

예시를 들어보면 토픽 이름이 A이고 파티션 수가 2일 때, 프로듀서는 토픽A로 메시지를 전송하는데, 메시지의 키는 user123입니다.  
메시지의 키값 user123은 프로듀서의 기본 파티셔너를 거치면서 해시 알고리즘을 통해 토픽A의 1번 파티션과 매핑됩니다. 이후부터 메시지 키값이 user123인 메시지는 항상 토픽A의 1번 파티션으로 전송됩니다.    

관리자는 토픽A를 잘 이용하고 있었으나, 성능상의 이슈로 인해 해당 토픽의 파티션 수를 확장해야 했고, 토픽 A의 파티션 수를 2에서 4로 늘렸습니다.  
파티션 수가 4로 변경된 후 메시지의 키값을 기준으로 파티션과 매핑된 테이블도 변경되어 메시지 키값 user123은 3번 파티션으로 할당되었습니다.  
이후부터 메시지 키값이 user123인 메시지는 항상 토픽A의 3번 파티션으로 전송됩니다.  

이렇게 메시지의 키를 이용해 카프카로 메시지를 전송하는 경우, 관리자의 의도와는 다른 방식으로 메시지 전송이 이뤄질 수 있으므로 되도록 파티션 수를 변경하지 않는 것을 권장합니다.  

## 5.1.1 라운드 로빈 전략

만약 키값을 지정하지 않는다면 키값은 null이 되고, 기본값인 라운드 로빈 알고리즘을 사용해 프로듀서는 목적지 토픽의 파티션들로 레코드들을 랜덤 전송합니다.  
파티셔너를 거친 후의 레코드들은 배치 처리를 위해 프로듀서의 버퍼 메모리 영역에서 잠시 대기한 후 카프카로 전송됩니다.  

배치 처리를 위해 잠시 메시지들이 대기하는 과정에서 라운드 로빈 전략은 효율을 떨어뜨릴 수 있습니다.  
토픽A는 총 3개의 파티션으로 구성되어 있고, 각 파티션별로 배치 전송을 위해 필요한 레코드 수는 3입니다.  

프로듀서는 키값이 null인 레코드(메시지)1을 보내고 파티셔너는 키값이 null인 레코드를 확인해서 라운드 로빈 전략으로 토픽A-파티션0에 레코드 1을 담아놓습니다.  
이 메시지는 즉시 카프카로 전송되지 않은 채 배치 전송을 위해 프로듀서의 버퍼 메모리에서 잠시 대기합니다.  

다음으로 프로듀서는 키값이 null인 레코드 2를 보내고, 파티셔너는 라운드 로빈 전략으로 토픽A-파티션1에 레코드2를 담아놓습니다.  
동일한 방법으로 키값이 null인 레코드들이 총 5개 전송되고 라운드 로빈 전략에 의해 각 파티션에 하나씩 순차적으로 할당됩니다.  

총 5개의레코드가 파티셔너를 거쳐 지나갔지만 카프카로 전송되지 못한 채 프로듀서 내에서 대기하고 있습니다.  
이는 배치전송을 위한 최소 레코드 수가 3으로 설정되어 있는데, 파티션에 최소 레코드 수의 기준인 3을 충족하지 못했기 때문입니다.  

물론 관리자는 프로듀서의 옵션을 조정해서 특정 시간을 초고하하면 즉시 카프카로 레코드들을 전송하도록 설정할 수 있습니다.  
하지만 배치와 압축의 효과를 얻지 못한채 레코드 하나만 카프카로 전송될 수 있기 때문에 매우 비효율적입니다.  

카프카에서는 이와 같은 비효율적인 전송을 보완하기 위해 스티키 파티셔닝(sticky partitioning)전략을 공개했습니다.  

## 5.1.2 스티키 파티셔닝 전략  

라운드 로빈 전략에서 지연시간이 불필요하게 증가되는 비효율적인 전송을 개선하고자 카프카 2.4 버전부터는 스티키 파티셔닝 전략을 사용하게 됩니다.  
라운드 로빈 전략에서 배치전송을 위한 필요 레코드 수를 채우지 못해 카프카로 배치 전송을 하지 못했던 것과 달리, 스티키 파티셔닝이란 하나의 파티션에 레코드 수를 먼저 채워서 카프카로 빠르게 배치 전송하는 전략을 말합니다.  

토픽의 파티션 수는 3이고 배치를 위한 최소 레코드 수는 3입니다.  

프로듀서는 키값이 null인 레코드1을 보내고, 파티셔너는 키값이 null인 레코드를 확인하고 배치를 위해 임의의 토픽 A-파티션0에 레코드1을 담아놓습니다.  
그러고 나서 프로듀서는 키값이 null인 레코드2를 보내고, 파티셔너는 조금 전 토픽A-파티션0에 레코드2를 담아놓습니다.  

이런 방법으로 파티셔너는 배치를 위한 레코드 수에 도달할 때까지 다른 파ㅣ션으로 보내지 않고 동일한 파티션으로 레코드를 담아놓습니다.  
토픽A-파티션0에 레코드 1~3까지 채워졌고 이 레코드들은 배치를 위한 최소 레코드 수를 충족했으므로 즉시 카프카로 배치 전송이 수행될 것입니다.  

라운드 로빈 전략에서는 레코드 5개를 처리했음에도 카프카로 전송하지 못했지만, 스티키 파티셔닝 전략에서는 성공적으로 배치 전송을 할 수 있었습니다.  
이렇듯 스티키 파티셔닝 전략은 라운드 로빈 전략에 비해 분명히 효율적인 전송 방법입니다.  

카프카로 전송하는 메시지의 순서가 그다지 중요하지 않은 경우라면 스티키 파티셔닝 전략을 적용하기를 권장합니다.  







