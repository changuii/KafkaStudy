# 5.4 정확히 한 번 전송  

데이터 처리나 가공 작업을 하는 대부분의 사람들은 데이터 파이프라인에서 메시지 중복이나 손실이 발생하지 않기를 원합니다.  
가장 이상적인 상황이라면 모든 메시지를 정확히 한 번 처리해주기를 원합니다.  

은행의 사례  
A가 자신의 계좌에서 돈을 인출해 B의 계좌로 돈을 송급했습니다.  
해당 이벤트는 크게 A계좌의 출금 이벤트, B계좌로의 입금 이벤트로 나눌 수 있습니다.  
A계좌에서 출금 이벤트가 중복되어 두 차례 발생하거나, A계좌에서 출금 이벤트는 유실되고 B계좌에 입금 이벤트만 처리된다면 은행은 매우 곤란한 상황에 처할 것입니다.  

만약 메시지를 처리하는 애플리케이션에서 중복 없는 전송 또는 정확히 한 번 처리하는 기능을 제공한다면 이는 매우 반가운 일입니다.  
앞서 카프카에서는 멱등성 옵션을 이용해 중복 없는 전송을 할 수 있다고 설명했습니다.  

하지만 이 중복 없는 전송이 정확히 한 번 전송한다는 의미는 아닙니다.  
카프카에서 정확히 한 번 전송은 트랜잭션과 같은 전체적인 프로세스 처리를 의미하며, 중복 없는 전송은 정확히 한 번 전송의 일부 기능이라 할 수 있습니다.  

전체적인 프로세스를 관리하기 위해 카프카에서는 정확히 한 번 처리를 담당하는 별도의 프로세스가 있는데 이를 트랜잭션API라고 부릅니다.  

## 5.4.1 디자인

프로듀서가 카프카로 정확히 한 번 방식으로 메시지를 전송할 때, 프로듀서가 보내는 메시지들은 원자적으로(Atomic) 처리되어 전송에 성공하거나 실패하게 됩니다.  
이런 프로듀서의 전송을 위해 카프카에는 컨슈머 그룹 코디네이터와 동일한 개념으로 트랜잭션 코디네이터(transaction coordinator)라는 것이 서버 측에 존재합니다.  

이 트랜잭션 코디네이터의 역할은 프로듀서에 의해 전송된 메시지를 관리하며, 커밋 또는 중단 등을 표시합니다.  
카프카에서는 컨슈머 오프셋 관리를 위해 오프셋 정보를 카프카 내부 토픽에 저장하는데, 트랜잭션도 동일하게 트랜잭션 로그를 카프카의 내부 토픽인 _transaction_state에 저장합니다.  
_transaction_state는 카프카의 내부 토픽이지만 이 역시 토픽이므로 파티션 수와 리플리케이션 팩터 수가 존재하며, 브로커의 설정을 통해 관리자가 설정할 수 있습니다.  

프로듀서는 트랜잭션 관련 정보를 트랜잭션 코디네이터에게 알리고, 모든 정보의 로그는 트랜잭션 코디네이터가 직접 기록합니다.  
정확히 한 번 전송을 이용해 전송된 메시지들이 카프카에 저장되면, 카프카의 메시지를 다루는 클라이언트들은 해당 메시지들이 정상적으로 커밋된 것인지 또는 실패한 것인지 식별할 수 있어야 합니다.  

카프카에서는 이를 식별하기 위한 정보로서, 컨트롤 메시지라고 불리는 특별한 타입의 메시지가 추가로 사용됩니다.  
컨트롤 메시지는 페이로드에 애플리케이션 데이터(메시지의 밸류)를 포함하지 않으며, 애플리케이션들에게 노출되지 않습니다.  

컨트롤 메시지는 오직 브로커와 클라이언트 통신에서만 사용됩니다.  

## 5.4.2 단계별 동작  

정확히 한 번 전송을 위해서는 트랜잭션 API를 이용한다고 설명했습니다.  
따라서 가장 먼저 수행하는 작업은 트랜잭션 코디네이터 찾기 입니다.  

프로듀서는 브로커에게 FindCoordinator Request를 보내서 트랜잭션 코디네이터의 위치를 찾습니다.  
컨슈머 코디네이터와 유사한 역할을 하는 트랜잭션 코디네이터는 브로커에 위치합니다.  

트랜잭션 코디네이터의 주 역할은 PID와 transactional.id를 매핑하고 해당 트랜잭션 전체를 관리하는 것입니다.  
만약 트랜잭션 코디네이터가 존재하지 않는다면 신규 트랜잭션 코디네이터가 생성됩니다.  

_transaction_state 토픽의 파티션 번호는 transactional.id를 기반으로 해시하여 결정되고, 이 파티션의 리더가 있는 브로커가 트랜잭션 코디네이터의 브로커로 최종 선정됩니다.  
이는 transactional.id가 정확히 하나의 코디네이터만 갖고 있다는 의미와도 같습니다.  

다음으로 프로듀서 초기화 동작입니다.  
프로듀서는 initTranscations() 메소드를 이용해 트랜잭션 전송을 위한 InitPidRequest를 트랜잭션 코디네이터로 보냅니다.  

이때 TID(Transactional.id)가 설정된 경우에는 InitPidRequest와 함께 TID가 트랜잭션 코디네이터에게 전송됩니다.  
트랜잭션 코디네이터는 TID, PID를 매핑하고 해당 정보를 트랜잭션 로그에 기록합니다.  

그런 다음 PID 에포크(epoch)를 한 단계 올리는 동작을 하게 되고, PID 에포크가 올라감에 따라 이전의 동일한 PID와 이전 에포크에 대한 쓰기 요청은 무시됩니다.  
에포크를 활용하는 이유는 신뢰성 있는 메시지 전송을 하기 위함입니다. (4장 leaderEpoch 참고)  

그다음으로는 트랜잭션 시작 동작입니다.  
프로듀서는 beginTransaction() 메소드를 이용해 새로운 트랜잭션의 시작을 알리게 됩니다.  

프로듀서는 내부적으로 트랜잭션이 시작됐음을 기록하지만, 트랜잭션 코디네이터 관점에서는 첫 번째 레코드가 전송될 때까지 트랜잭션이 시작된 것은 아닙니다.  

그다음으로는 트랜잭션 상태 추가 동작입니다.  
트랜잭션 코디네이터는 전체 트랜잭션을 관리합니다.  
그리고 각 트랜잭션 상태의 내용을 기록하는 일도 매우 중요합니다.  

프로듀서는 토픽 파티션 정보를 트랜잭션 코디네이터에게 전달하고, 트랜잭션 코디네이터는 해당 정보를 트랜잭션 로그에 기록합니다.  
TID와 P0(파티션0)의 정보가 트랜잭션 로그에 기록되며, 트랜잭션의 현재 상태를 Ongoing으로 표시합니다.  

만약 트랜잭션 로그에 추가되는 첫 번째 파티션이라면, 트랜잭션 코디네이터는 해당 트랜잭션에 대한 타이머를 시작합니다.  
기본값으로 1분 동안 트랜잭션 상태에 대한 업데이트가 없다면, 해당 트랜잭션은 실패로 처리됩니다.  

다음은 메시지 전송입니다.  
이 단계에서 프로듀서는 대상 토픽의 파티션으로 메시지를 전송합니다.  

P0(파티션0)으로 메시지를 전송했고, 해당 메시지에는 PID, 에포크, 시퀀스 번호가 함께 포맣되어 전송됩니다.  
브로커가 2개 있는 이유는 트랜잭션 코디네이터가 있는 브로커와 프로듀서가 전송하는 메시지를 받는 브로커가 서로 다르기 때문입니다.  

그다음으로는 트랜잭션 종료 요청 동작입니다.  
메시지 전송을 완료한 프로듀서는 commitTransaction() 메소드 또는 abortTransaction() 메소드 중 하나를 반드시 호출해야 하며, 해당 메소드의 호출을 통해 트랜잭션이 완료됨을 트랜잭션 코디네이터에게 알립니다.  

트랜잭션 코디네이터는 두 단계의 커밋 과정을 시작하게 되며, 첫 번째 단계로 트랜잭션 로그에 해당 트랜잭션에 대한 PrepareCommit 또는 PrepareAboprt를 기록합니다.  

다음은 사용자 토픽에 표시하는 단계입니다.  
트랜잭션 코디네이터는 두 번째 단계로 트랜잭션 로그에 기록된 토픽의 파티션에 트랜잭션 커밋 표시를 기록합니다.  
여기서 기록하는 메시지가 바로 컨트롤 메시지입니다.  

예를 들어, 트랜잭션 프로듀서가 파티션0에 메시지를 전송했고 해당 메시지의 오프셋이 1이라고 가정해봅시다.  
트랜잭션 코디네이터는 파티션0에 트랜잭션 커밋 표시 메시지를 기록하고, 이 추가 메시지(컨트롤 메시지)로 인해 파티션0의 마지막 오프셋은 2로 증가합니다.  

이 메시지는 해당 PID의 메시지가 제대로 전송됐는지 여부를 컨슈머에게 나타내는 용도로도 사용됩니다.  
따라서 트랜잭션이 커밋이 끝나지 않은 메시지는 컨슈머에게 반환하지 않으며, 오프셋의 순서 보장을 위해 트랜잭션 성공 또는 실패를 나타내는 LSO(last stable offset)라는 오프셋을 유지하게 됩니다.  

이제 마지막 단계인 트랜잭션 완료입니다.  
트랜잭션 코디네이터는 완료됨(Committed)이라고 트랜잭션 로그에 기록합니다.  

그리고 프로듀서에게 해당 트랜잭션이 완료됨을 알린 다음 해당 트랜잭션에 대한 처리는 모두 마무리됩니다.  
트랜잭션을 이용하는 컨슈머는 read_committed 설정을 하면 트랜잭션에 성공한 메시지들만 읽을 수 있게 됩니다.  






