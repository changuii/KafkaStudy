# 4.2 컨트롤러

카프카 클러스터 중 하나의 브로커가 컨트롤러 역할을 하게 되며, 파티션의 ISR 리스트 중에서 리더를 선출합니다.  
리더를 선출하기 위한 ISR 리스트 정보는 안전한 저장소에 보관되어 있어야 하는데, 가용성 보장을 위하여 주키퍼에 저장되어 있습니다.  

컨트롤러는 브로커가 실패하는 것을 예의주시하고 있으며, 만약 브로커의 실패가 감지되면 즉시 ISR 리스트 중 하나를 새로운 파티션 리더로 선출합니다.  
그리고 나서 새로운 리더의 정보를 주키퍼에 기록하고, 변경된 정보를 모든 브로커에게 전달합니다.  

## 4.2.1 예기치 않은 종료에서의 리더 선출 작업

파티션의 리더가 다운됐다는 것은 해당 파티션의 리더가 없는 상태를 의미하며, 카프카 클라이언트가 읽기/쓰기를 하지 못하면 모든 읽기/쓰기 동작은 실패하게 되고, 클라이언트에 설정되어 있는 재시도 숫자만큼 재시도를 하게 됩니다.  
따라서 클라이언트들이 재시도하는 시간 내에 리더 선출 작업이 빠르게 이뤄져야 합니다.  

peter-test02 토픽 정보  
| 토픽 이름            | peter-test02  |
| -------------------- | ------------- |
| 파티션 수            | 1             |
| 리플리케이션 팩터 수 | 2             |
| 브로커 배치          | 1, 3번 브로커 |
| 현재 리더 위치       | 1번 브로커 |
  
이제 장애 상황을 연출하기 위해 0번 파티션의 리더가 있는 1번 브로커를 강제로 종료하고 새로운 파티션의 리더가 선출되는 과정을 살펴보겠습니다.  

1. 파티션 0번 리더가 있는 브로커1번이 예기치 않게 다운됩니다.  
2. 주키퍼는 1번 브로커와 연결이 끊어진 후, 0번 파티션의 ISR에서 변화가 생겼음을 감지합니다.
3. 컨트롤러는 주키퍼 워치를 통해 0번 파티션에 변화가 생긴 것을 감지하고, 해당 파티션 ISR 중 3번을 새로운 리더로 선출합니다.  
4. 컨트롤러는 0번 파티션의 새로운 리더가 3이라는 정보를 주키퍼에 기록합니다.
5. 이렇게 갱신된 정보는 현재 활성화 상태인 모든 브로커에게 전파됩니다.

리더 선출 과정은 컨트롤러에 의해 이루어집니다.  
파티션이 하나인 경우, 컨트롤러가 새로운 리더를 선출하고 리더 정보를 주키퍼에 기록하며 다른 브로커들에게 업데이트 정보를 전파하는 데는 그리 오랜 시간이 걸리지 않습니다.  

하나의 파티션에 대해 리더 선출 작업이 약 0.2초가 걸린다고 가정한다면, 파티션이 1개일 경우에는 0.2초 만에 완료됩니다.  
하지만 1만개의 파티션에 대해 리더 선출이 이뤄져야 한다면, 전체 작업 소요시간은 2000초가 걸리며 이는 분 단위로 환산하면 30분이 조금 넘는 시간입니다.  
1대의 브로커가 발생하고, 새로운 리더 선출 작업으로 카프카와 클라이언트 간에 30여분간 통신이 끊어지는 사태가 발생한다면, 실시간 데이터 처리를 수행하는 부서들은 모두 장애 상황을 겪게될 것입니다.  

카프카 1.0.0에서 6분30초 소요되던 작업이, 불필요한 로깅을 없애고 주키퍼 비동기 API가 반영된 카프카 버전 1.1.0에서는 약 3초만에 완료되었습니다.  
따라서 카프카 최신버전에서는 이런 문제에 대해서는 안심할 수 있습니다.  

## 4.2.2 제어된 종료에서의 리더 선출 작업

이번에는 제어된 종료 과정에서의 리더 선출 작업을 살펴보겠습니다.  
제어된 브로커 종료란, 예기치 않은 브로커의 실패나 장애가 아니라 관리자에 의해 이뤄지는 자연스러운 종료 또는 안전한 종료를 생각하면 됩니다.  

1. 관리자가 브로커 종료 명령어를 실행하고, SIG_TERM 신호가 브로커에게 전달됩니다.  
2. SIG_TERM 신호를 받은 브로커는 컨트롤러에게 알립니다.  
3. 컨트롤러는 리더 선출 작업을 진행하고, 해당 정보를 주키퍼에 기록합니다.
4. 컨트롤러는 새로운 리더 정보를 다른 브로커들에게 전송합니다.
5. 컨트롤러는 종료 요청을 보낸 브로커에게 정상 종료한다는 응답을 보냅니다.
6. 응답을 받은 브로커는 캐시에 있는 내용을 디스크에 저장하고 종료합니다.  

그렇다면 제어된 종료와 급작스러운 종료의 가장 큰 차이는 무엇일까요?  
바로 다운타임(downtime)입니다. 제어된 종료를 사용하면 카프카 내부적으로 파티션들의 다운타임을 최소화할 수 있습니다.  

그 이유는 브로커가 종료되기 전, 컨트롤러는 해당 브로커가 리더로할당된 전체 파티션에 대해 리더 선출 작업을 진행하기 때문입니다.  
물론 제어된 종료라 할지라도 리더 선출 작업 시간 동안 일시적으로 다운 타임이 발생합니다.  

하지만 리더 선출 작업 대상 파티션들의 리더들이 활성화된 상태에서 컨트롤러는 순차적으로 하나의 파티션마다 리더를 선출하게 되므로, 결과적으로 각 파티션들은 다운타임을 최소화할 수 있습니다.  

이번에는 브로커 장애로 인한 리더 선출 작업을 살펴보겠습니다.  
이미 대상 파티션들의 리더가 종료된 상태이고, 파티션들의 다운타임은 새로운 리더 선출 작업이 될 때까지 지속되고 있습니다.  

컨트롤러는 순차적으로 하나의파티션마다 리더를 선출하게 되며, 첫 번째 대상 파티션의 다운타임은 길지 않지만 마지막 대상 파티션의 다운타임은 꽤 오랜 시간이 걸립니다.  
그뿐 아니라 제어된 종료의 경우 브로커는 자신의 모든 로그를 디스크에 동기화한 후 종료되므로, 이후 다시 브로커가 재시작할 때 로그 복구 시간이 짧습니다.  





