# 4.3 로그 (로그 세그먼트)

카프카의 토픽으로 들어오는 메시지(레코드)는 세그먼트(segment, log segment)라는 파일에 저장됩니다.  
로그 세그먼트에는 메시지의 내용만 저장되는 것이 아니라 메시지의 키, 밸류, 오프셋, 메시지 크기 같은 정보가 함께 저장되며, 로그 세그먼트 파일들은 브로커의 로컬 디스크에 보관됩니다.  

하나의 로그 세그먼트 크기가 너무 커져버리면 파일을 관리하기 어렵기 때문에, 로그 세그먼트의 최대 크기는 1GB가 기본값으로 설정되어 있습니다.  
로그 세그먼트가 1GB보다 커지는 경우에는 기본적으로 롤링(rolling) 전략을 적용합니다.  

다시말해, 하나의 로그 세그먼트에 카프카로 인입되는 메시지들을 계속해서 덧붙이다가 로그 세그먼트의  크기가 1GB에 도달하면 해당 세그먼트 파일을 클로즈(close)하고, 새로운 로그 세그먼트를 생성하는 방식으로 진행됩니다.  
카프카에 기본적으로 로그 세그먼트 파일에 대한 롤링 전략이 준비되어 있긴 하지만, 카프카 관리자는 1GB 크기의 로그 세그먼트 파일이 무한히 늘어날 경우를 대비해 로그 세그먼트에 대한 관리 계획을 수립해 두어야 합니다.  

크게 로그 세그먼트 삭제와 컴팩션(compaction)으로 구분할 수 있습니다.  

## 4.3.1 로그 세그먼트 삭제  

로그 세그먼트의 삭제 작업은 일정 주기를 가지고 체크하는데, 카프카의 기본값은 5분 주기이므로 5분 간격으로 로그 세그먼트 파일을 체크하면서 삭제 작업을 수행합니다.  
따라서 명려어 실행 뒤 로그 세그먼트 파일이 삭제되는 것이 아니라 약 5분 후에 삭제 작업이 일어납니다.  

관리자가 설정한 일정 주기마다 로그 세그먼트가 삭제됩니다.  

## 4.3.2 로그 세그먼트 컴팩션

컴팩션(compaction)은 카프카에서 제공하는 로그 세그먼트 관리 정책 중 하나로, 로그를 삭제하지 않고 컴팩션하여 보관할 수 있습니다.  
로그 컴팩션은 기본적으로 로컬 디스크에 저장되어 있는 세그먼트를 대상으로 실행되는데, 현재 활성화된 세그먼트는 제외하고 나머지 세그먼트들을 대상으로 컴팩션이 실행됩니다.  

컴팩션할지라도 카프카의 로컬 디스크에 로그를 무기한 보관한다면, 로그의 용량은 감당할 수 없이 커져서 디스크가 저장할 수 있는 용량의 한계에 도달할 것입니다.  
따라서 카프카에서는 단순하게 메시지를 컴팩션하여 보관하기보다는 좀 더 효율적인 방법으로 컴팩션합니다.  

카프카에서 로그 세그먼트를 컴팩션하면 메시지(레코드)의 키값을 기준으로 마지막의 데이터만 보관하게 됩니다.  
로그 컴팩션 기능을 이용하는 대표적인 예제는 바로 카프카의 _consumer_offset 토픽입니다.  

_consumer_offset 토픽은 카프카의 내부 토픽으로, 컨슈머 그룹의 정보를 저장하는 토픽입니다.  
각 컨슈머 그룹의 중요한 정보는 해당 컨슈머 그룹이 어디까지 읽었는지를 나타내는 오프셋 커밋 정보인데, _consumer_offset에 키(컨슈머 그룹명, 토픽명)와 밸류(오프셋 커밋 정보) 형태로 메시지가 저장됩니다.  

예를 들어 CG01 컨슈머 그룹이 T01 토픽을 컨슘하고, 첫 번째 메시지를 읽고 커밋했다고 가정하겠습니다.  
이 정보는 키와 밸류 형태의 메시지로 _consumer_offset 토픽에 저장되어야 합니다.  
따라서 키는 CG01(컨슈머 그룹), T01(토픽명)이고 밸류는 1(오프셋)인 메시지가 _consumer_offset 토픽에 저장됩니다.  

약 한 시간 후에 CG01 컨슈머 그룹이 T01 토픽을 컨슘하고 나서 두 번째 메시지를 읽고 커밋하면, 키가 (CG01, T01)이고 밸류는 2인 메시지가 _consumer_offset 토픽에 저장됩니다.  
또 한 시간이 지나 세 번째 메시지를 읽고 커밋하면, 키가 (CG01, T01)이고 밸류는 3인 메시지가 _consumer_offset 토픽에 저장됩니다.  

현재 _consumer_offset 토픽에 저장된 메시지는 총 3개이고, 키 (CG01, T01)을 기준으로 밸류가 1, 2, 3인 메시지 입니다.  
이후 로그 컴팩션 동작이 일어나면 키값이 (CG01, T01)인 메시지의 마지막 데이터인 3만 남게됩니다.  

컨슈머 그룹은 항상 마지막으로 커밋된 오프셋 정보가 중요하므로, 과거에 커밋된 정보들은 삭제돼도 무방합니다.  

또다른 예시로는 현재의 구매 현황 상태를 보여주는 시스템에서도 로그 컴팩션을 사용할 수 있습니다.  
구매 상태 정보는 주문완료 -> 배송 준비 -> 배송 중 -> 배송 완료의 총 4단계로 나타냅니다.  

구매한 사용자를 기준으로 최종 상태만 사용자에게 노출하면 되므로, 카프카의 로그 컴팩션 기능을 사용할 수 있습니다.  

로그 컴팩션 이전  
| 오프셋 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  |
| ------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 키     | K1  | K2  | K1  | K1  | K3  | K2  | K4  | K5  | K5  | K2  | K6  |
| 밸류   | V1  | V2  | V3  | V4  | V5  | V6  | V7  | V8  | V9  | V10 | V11 |  


로그 컴팩션 이후  
| 오프셋 | 3   | 4   | 6   | 8   | 9   | 10  |
| ------ | --- | --- | --- | --- | --- | --- |
| 키     | K1  | K3  | K4  | K5  | K2  | K6  |
| 밸류   | V4  | V5  | V7  | V9  | V10 | V11 |  

프로듀서가 카프카로 메시지를 전송할 때, 메시지에는 메시지(레코드)의 키와 밸류를 같이 전송하게 됩니다.  
밸류는 필숫값이지만 키는 필숫값이 아닙니다.  
따라서 로그 컴팩션 기능을 사용하고자 한다면, 카프카로 메시지를 전송할 때 키도 필숫값으로 전송해야 합니다.  
  
로그 컴팩션의 장점은 빠른 장애 복구입니다.  
장애 복구 시 전체 로그를 복구하지 않고, 메시지의 키를 기준으로 최신의 상태만 복구합니다.  
따라서 전체 로그를 복구할 때보다 복구 시간을 줄일 수 있다는 장점이 있습니다.  

하지만 빠른 재처리라는 장점이 있다고 해서 모든 토픽에 로그 컴팩션을 적용하는 것은 좋지 않습니다.  
키값을 기준으로 최종값만 필요한 워크로드에 적용하는 것이 바람직합니다.  

카프카에서 로그 컴팩션 작업이 실행되는 동안 브로커의 과도한 입출력 부하가 발생할 수 있으니 유의해야 합니다.  
  











